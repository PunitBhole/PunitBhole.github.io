<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<style>
body {font-family: Arial, Helvetica, sans-serif;
background-image: url("grey1.jpg");
  background-repeat: no-repeat;
  background-attachment: fixed;}

/* Full-width input fields */
input[type=text], input[type=password] {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    box-sizing: border-box;
}

/* Set a style for all buttons */
button {
    background-color: #4CAF50;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    cursor: pointer;
    width: 100%;
}

button:hover {
    opacity: 0.8;
}

/* Extra styles for the cancel button */
.cancelbtn {
    width: auto;
    padding: 10px 18px;
    background-color: #f44336;
}

/* Center the image and position the close button */
.imgcontainer {
    text-align: center;
    margin: 24px 0 12px 0;
    position: relative;
}

img.avatar {
    width: 40%;
    border-radius: 50%;
}

.container {
    padding: 16px;
}

span.psw {
    float: right;
    padding-top: 16px;
}

/* The Modal (background) */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    padding-top: 60px;
}

/* Modal Content/Box */
.modal-content {
    background-color: #fefefe;
    margin: 5% auto 15% auto; /* 5% from the top, 15% from the bottom and centered */
    border: 1px solid #888;
    width: 85%; /* Could be more or less, depending on screen size */
    
    overflow-y: auto;
}

/* The Close Button (x) */
.close {
    position: absolute;
    right: 25px;
    top: 0;
    color: #000;
    font-size: 35px;
    font-weight: bold;
}

.close:hover,
.close:focus {
    color: red;
    cursor: pointer;
}

/* Add Zoom Animation */
.animate {
    -webkit-animation: animatezoom 0.6s;
    animation: animatezoom 0.6s
}

@-webkit-keyframes animatezoom {
    from {-webkit-transform: scale(0)} 
    to {-webkit-transform: scale(1)}
}
    
@keyframes animatezoom {
    from {transform: scale(0)} 
    to {transform: scale(1)}
}

/* Change styles for span and cancel button on extra small screens */
@media screen and (max-width: 300px) {
    span.psw {
       display: block;
       float: none;
    }
    .cancelbtn {
       width: 100%;
    }
}
</style>
</head>
<body>

<center>
<h2 align="center">ADS CODES</h2>

<button onclick="document.getElementById('id01').style.display='block'" style="width:auto;">Binary Tree and its Operations</button><br>
<button onclick="document.getElementById('id02').style.display='block'" style="width:auto;">Binary Search Tree and its Operations</button><br>
<button onclick="document.getElementById('id03').style.display='block'" style="width:auto;">Adjacency Matrix : Flights Path</button><br>
<button onclick="document.getElementById('id04').style.display='block'" style="width:auto;">Student Data Handling</button><br>
<button onclick="document.getElementById('id05').style.display='block'" style="width:auto;">Telephone Book</button><br>
<button onclick="document.getElementById('id06').style.display='block'" style="width:auto;">Threaded Binary Tree</button><br>
<button onclick="document.getElementById('id07').style.display='block'" style="width:auto;">Dictionary</button><br>
<button onclick="document.getElementById('id08').style.display='block'" style="width:auto;">Exceptions</button><br>
<button onclick="document.getElementById('id09').style.display='block'" style="width:auto;">AVL Tree</button><br>
<button onclick="document.getElementById('id10').style.display='block'" style="width:auto;">Prims Algorithm : Phone Line Between Cities</button><br>
<button onclick="document.getElementById('id11').style.display='block'" style="width:auto;">Linked List Demo</button><br>
<button onclick="document.getElementById('id12').style.display='block'" style="width:auto;">Queue Demo</button><br>
<button onclick="document.getElementById('id13').style.display='block'" style="width:auto;">Stack Demo</button><br>
<button onclick="document.getElementById('id14').style.display='block'" style="width:auto;">Set Functions</button><br>
</center>


<div id="id01" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id01').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
  <h5>Problem Statement : Write a program in C++ to generate a Binary Tree to implement the following functionalities -
        <ol type="i">
          <li>create()</li>
          <li>insert()</li>
          <li>erase()()</li>
          <li>display()</li>
          <li>inorder()()</li>
          <li>postorder()()</li>
          <li>preorder()</li>
          <li>mirror()</li>
        </ol></h5>

        <h5>Code :</h5>
<xmp>
#include<iostream>
using namespace std;

class node
{
public:
  char data;
  node *left;
  node *right;
};

class stack
{
public:
  node *ptr;
};

class tree
{
  node *root=NULL;
public:
  void create();
  void insert(node *curr);
  void operator =(tree t1);
  void erase(node *temp);
  void erasenodes();
  void inorder_itr();
  void preorder_itr();
  void postorder_itr();
  void indisplay();
  void inorder(node *curr);
  void predisplay();
  void preorder(node *curr);
  void postdisplay();
  void postorder(node *curr);
  node* copy(node *original);
  void mirror_image(tree t1);
  node* mirror(node *original);
};

void tree::create()
{
  if(root==NULL)
  {
    root=new node;
    cout<<"\nEnter the data for root node : ";
    cin>>root->data;
    insert(root);
  }
  else
    cout<<"\nThe tree is already created. ";
}

void tree::insert(node *curr)
{
  char ans;
  node *temp;
  cout<<"\nDoes the node "<<curr->data<<" has a left child? (y/n) : ";
  cin>>ans;
  if(ans=='y'||ans=='Y')
  {
    temp=new node;
    cout<<"\nEnter data for left child of "<<curr->data<<" node : ";
    cin>>temp->data;
    curr->left=temp;
    insert(temp);
  }
  cout<<"\nDoes the node "<<curr->data<<" has a right child? (y/n) : ";
  cin>>ans;
  if(ans=='y'||ans=='Y')
  {
    temp=new node;
    cout<<"\nEnter data for right child of "<<curr->data<<" node : ";
    cin>>temp->data;
    curr->right=temp;
    insert(temp);
  }
}

void tree::operator =(tree t1)
{
  root=copy(t1.root);
}

node* tree::copy(node *original)
{
        node *temp;
  if(original)
  {
          temp=new node;
    temp->data=original->data;
    temp->left=copy(original->left);
    temp->right=copy(original->right);
    return temp;
  }
  return 0;
}

void tree::mirror_image(tree t1)
{
  root=mirror(t1.root);
  cout<<"\n\n\tThe mirror image of the tree by is : ";
  cout<<"\n\n\tInorder : ";
        indisplay();
        cout<<"\n\tPreorder : ";
        predisplay();
        cout<<"\n\tPostorder : ";
        postdisplay();

}

node* tree::mirror(node *original)
{
        node *temp;
  if(original)
  {
          temp=new node;
    temp->data=original->data;
    temp->left=mirror(original->right);
    temp->right=mirror(original->left);
    return temp;
  }
  return 0;
}

void tree::indisplay()
{
  if(root!=NULL)
  {
    cout<<"\n";
    inorder(root);
    cout<<"\n";
  }
  else
    cout<<"\n\tThe tree is empty";
}

void tree::inorder(node *curr)
{
  if(curr)
  {
    inorder(curr->left);
    cout<<"\t"<<curr->data;
    inorder(curr->right);
  }
}

void tree::predisplay()
{
  if(root!=NULL)
  {
    cout<<"\n";
    preorder(root);
    cout<<"\n";
  }
  else
    cout<<"\n\tThe tree is empty";
}

void tree::preorder(node *curr)
{
  if(curr)
  {
    cout<<"\t"<<curr->data;
    preorder(curr->left);
    preorder(curr->right);
  }
}

void tree::postdisplay()
{
  if(root!=NULL)
  {
    cout<<"\n";
    postorder(root);
    cout<<"\n";
  }
  else
    cout<<"\n\tThe tree is empty";
}

void tree::postorder(node *curr)
{
  if(curr)
  {
    postorder(curr->left);
    postorder(curr->right);
    cout<<"\t"<<curr->data;
  }
}

void tree::inorder_itr()
{
  node *temp;
  int top=-1;
  stack s[20];
  temp=root;
  for(;;)
  {
    while(temp!=NULL)
    {
      top++;
      s[top].ptr=temp;
      temp=temp->left;
    }
    if(top>=0)
    {
      temp=s[top].ptr;
      top--;
      cout<<"\t"<<temp->data;
      temp=temp->right;
    }
    else
      break;
  }
}

void tree::preorder_itr()
{
  node *temp;
  int top=-1;
  stack s[20];
  temp=root;
  for(;;)
  {
    while(temp!=NULL)
    {
      cout<<"\t"<<temp->data;
      top++;
      s[top].ptr=temp;
      temp=temp->left;
    }
    if(top>=0)
    {
      temp=s[top].ptr;
      top--;
      temp=temp->right;
    }
    else
      break;
  }
}

void tree::postorder_itr()
{
        node *temp;
        stack s[20];
        int  top=-1;
        temp=root;
        while(1)
        {
          while(temp!=NULL)
          {
                  top++;
      s[top].ptr=temp;
                  temp=temp->left;
          }
        
                if(s[top].ptr->right==NULL)
                {
                        temp=s[top].ptr;
      top--;
                        cout<<"\t"<<temp->data;
                }
                while(s[top].ptr!=NULL && s[top].ptr->right==temp)
                {
                  temp=s[top].ptr;
      top--;
                  cout<<"\t"<<temp->data;
                }
                if(top==-1)
                {
                  break;
                }
                temp=s[top].ptr->right;
        }
}

void tree::erasenodes()
{
  erase(root);
}

void tree::erase(node *root)
{
  if(root!=NULL)
  {
    erase(root->left);
    erase(root->right);
    delete root;
  }
  this->root=NULL;
  
}

int main()
{
  tree t,t1;
  int x,y;
  char choice;
  do
  {
  
          cout<<"\n\n\n\tSelect any of the following choices : ";
          cout<<"\n\n\t\t(1) Create a tree";
          cout<<"\n\t\t(2) Display a tree";
          cout<<"\n\t\t(3) Copy one tree into another tree";
          cout<<"\n\t\t(4) Erase all nodes of the tree";
          cout<<"\n\t\t(5) Mirror image of the tree";
          cout<<"\n\n\tEnter any of the above choices : ";
          cin>>x;
          
                switch(x)
                {
                        case 1:
                                t.create();
                                break;
                        case 2:
                                cout<<"\n\n\n\tSelect any of the following choices : ";
                          cout<<"\n\n\t\t(1) Display by recursion";
                          cout<<"\n\t\t(2) Display without recursion";
                          cout<<"\n\n\tEnter any of the above choices : ";
                          cin>>y;
                          switch(y)
                          {
                                  case 1:
                                          cout<<"\n\n\tInorder : ";
                                          t.indisplay();
                                          cout<<"\n\tPreorder : ";
                                          t.predisplay();
                                          cout<<"\n\tPostorder : ";
                                          t.postdisplay();
                                          break;
                                  case 2:
                                          cout<<"\n\n\tInorder : ";
                                          t.inorder_itr();
                                          cout<<"\n\tPreorder : ";
                                          t.preorder_itr();
                                          cout<<"\n\tPostorder : ";
                                          t.postorder_itr();
                                          break;
                                  default:
                                          cout<<"\n\n\tERROR : wrong choice";
                                          break;
                          }
                          break;
                        case 3:
                                t1=t;
                                cout<<"\n\n\tThe copied tree by inorder display is : ";
                          cout<<"\n\n\tInorder : ";
                          t1.indisplay();
                                cout<<"\n\tPreorder : ";
                                t1.predisplay();
                                cout<<"\n\tPostorder : ";
                          t1.postdisplay();
                          break;
                  case 4:
                          t.erasenodes();
                          t.indisplay();
                          break;
                  case 5:
                          t1.mirror_image(t);
                          break;
                  default:
                          cout<<"\n\n\tERROR : wrong choice";
                                break;                
          }
          
          cout<<"\n\n\tDo you wish to continue? (y/n) : ";
          cin>>choice;
        }
        while(choice=='Y'||choice=='y');
  
  return 0;
}



/*

        OUTPUT : 
        
swaraj@swaraj:~/Desktop/ADS$ g++ btree_2.cpp
swaraj@swaraj:~/Desktop/ADS$ ./a.out



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 1

Enter the data for root node : A

Does the node A has a left child? (y/n) : Y

Enter data for left child of A node : B

Does the node B has a left child? (y/n) : N

Does the node B has a right child? (y/n) : N

Does the node A has a right child? (y/n) : Y

Enter data for right child of A node : C

Does the node C has a left child? (y/n) : N

Does the node C has a right child? (y/n) : N


  Do you wish to continue? (y/n) : Y



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 2



  Select any of the following choices : 

    (1) Display by recursion
    (2) Display without recursion

  Enter any of the above choices : 1


  Inorder : 
  B A C

  Preorder : 
  A B C

  Postorder : 
  B C A


  Do you wish to continue? (y/n) : Y



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 2



  Select any of the following choices : 

    (1) Display by recursion
    (2) Display without recursion

  Enter any of the above choices : 2


  Inorder :   B A C
  Preorder :  A B C
  Postorder :   B C A

  Do you wish to continue? (y/n) : Y



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 3


  The copied tree by inorder display is : 

  Inorder : 
  B A C

  Preorder : 
  A B C

  Postorder : 
  B C A


  Do you wish to continue? (y/n) : Y



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 5


  The mirror image of the tree by is : 

  Inorder : 
  C A B

  Preorder : 
  A C B

  Postorder : 
  C B A


  Do you wish to continue? (y/n) : Y



  Select any of the following choices : 

    (1) Create a tree
    (2) Display a tree
    (3) Copy one tree into another tree
    (4) Erase all nodes of the tree
    (5) Mirror image of the tree

  Enter any of the above choices : 4

  The tree is empty


  Do you wish to continue? (y/n) : N
swaraj@swaraj:~/Desktop/ADS$

*/
</xmp>

        
</pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id01').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<div id="id02" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id02').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
	<xmp>
  #include<iostream>
using namespace std;

class node
{
public:
        int data;
        node *left;
        node *right;
};

class bst
{
        node *root=NULL;
        public:
        void create();
        void display();
        void preorder(node *curr);
        void inorder(node *curr);
        void postorder(node *curr);
        void insert(node *curr,node *temp);
        int height(node *curr);
        void height_tree();
        int max(int,int);
        int min_val();
        void mirror(node *curr);
        void mirror_nodes();
        bool search(node *curr,int key);
        void search_val();
};


void bst::create()
{
        node *temp;
        char ans;
        do
        {
                temp=new node;
                cout<<"\n\tEnter the data : ";
                cin>>temp->data;
                temp->left=temp->right=NULL;
                if(root==NULL)
                {
                        root=temp;
                }
                else
                {
                        insert(root,temp);
                }
                cout<<"\n\tDo you wish to continue? (y/n) : ";
                cin>>ans;
        }
        while(ans=='y'||ans=='Y');
}

void bst::insert(node *curr,node *temp)
{
        if(curr->data>temp->data)
        {
                if(curr->left==NULL)
                {
                        curr->left=temp;
                }
                else
                        insert(curr->left,temp);
        }
        if(curr->data<temp->data)
        {
                if(curr->right==NULL)
                {
                        curr->right=temp;
                }
                else
                        insert(curr->right,temp);
        }
}

void bst::display()
{
  if(root==NULL)
  {
    cout<<"\n\tThe tree is empty";
  }
  else
  {
    cout<<"\n\tInorder : \n\t";
    inorder(root);
    cout<<"\n\tPreorder : \n\t";
    preorder(root);
    cout<<"\n\tPostorder : \n\t";
    postorder(root);
  }
}

void bst::inorder(node *curr)
{
  if(curr)
  {
    inorder(curr->left);
    cout<<"\t"<<curr->data;
    inorder(curr->right);
  }
}

void bst::preorder(node *curr)
{
  if(curr)
  {
    cout<<"\t"<<curr->data;
    preorder(curr->left);
    preorder(curr->right);
  }
}

void bst::postorder(node *curr)
{
  if(curr)
  {
    postorder(curr->left);
    postorder(curr->right);
    cout<<"\t"<<curr->data;
  }
}


int bst::min_val()
{
        node *curr=root;
        while(curr->left!=NULL)
        {
                curr=curr->left;
        }
        return curr->data;
}

void bst::mirror(node *curr)
{
        node *temp;
        if(curr==NULL)
                return;
        else
        {
                mirror(curr->left);
                mirror(curr->right);

                temp=curr->left;
                curr->left=curr->right;
                curr->right=temp;
        }
}


void bst::mirror_nodes()
{
        mirror(root);
        display();
}


int bst::max(int a,int b)
{
        if(a>b)
                return a;
        else
                return b;
}

int bst::height(node *curr)
{
  if(curr==NULL)
    return -1;
  else
    return(1+max(height(curr->left),height(curr->right)));
}

void bst::height_tree()
{
  cout<<"\n\tThe height of the binary search tree is : "<<height(root)<<endl;
}

bool bst::search(node *curr,int key)
{
  if(curr)
  {
    if(curr->data==key)
      return true;
    if(curr->data>key)
      return search(curr->left,key);
    else
      return search(curr->right,key);
  }
  return false;
}

void bst::search_val()
{
  int val;
        cout<<"\n\tEnter the value you wish to search : ";
        cin>>val;
        if(search(root,val))
                cout<<"\t\tThe entered value is present in the tree";
        else
                cout<<"\t\tThe entered value is not present in the tree";
}


int main()
{
  bst b;
  int x;
  char ans;
  do
  {
    cout<<"\n\n\t\t(1) Create a binary search tree";
    cout<<"\n\t\t(2) Display the tree";
    cout<<"\n\t\t(3) Find height of the tree";
    cout<<"\n\t\t(4) Minimum value of the tree";
    cout<<"\n\t\t(5) Search a value in the tree";
    cout<<"\n\t\t(6) Swap the roles of left and right pointers of the tree";
    cout<<"\n\n\tEnter any of the above options : ";
    cin>>x;
    switch(x)
    {
      case 1:
        b.create();
        break;
      case 2:
        b.display();
        break;
      case 3:
        b.height_tree();
        break;
      case 4:
        cout<<"\n\tThe minimum value in the tree is : "<<b.min_val()<<endl;
        break;
      case 5:
        b.search_val();
        break;
      case 6:
        b.mirror_nodes();
        break;
    }
    cout<<"\n\n\tDo you wish to continue? (y/n) : ";
    cin>>ans;
  }
  while(ans=='y'||ans=='Y');
  return 0;
}

</xmp>
        
</pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id02').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>





<!-- 3rd code. -->
<div id="id03" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id03').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>

      <b>Problem Statement</b>
        There are flight paths between cities. 
        If there is a flight between city A and city B then there is an edge between the cities. 
        The cost of the edge can be the time that flight take to reach city B from A, or the amount of fuel used for the journey. 
        Represent this as a graph. The node can be represented by airport name or name of the city. 
        Use adjacency list representation of the graph or use adjacency matrix representation of the graph. 
        Justify the storage representation used.

<xmp>
#include<iostream>
#include<iomanip>
using namespace std;

class node
{
public:
  string city;
  float time;
  node *next;
};

class flight
{
  node *header[10];
  int city_num;
  float adj[10][10];
  string city[10];
public:
  void create_list();
  void display_list();
  void init_adj();
  void create_matrix();
  void display_matrix();
};

void flight::create_list()
{
  node *temp,*curr;
  char ans;
  cout<<"\n\n\tEnter the total number of cities : ";
  cin>>city_num;
  cout<<"\n\n\tEnter the names of the cities : \n";
  for(int i=0;i<city_num;i++)
  {
    header[i]=new node;
    cout<<"\t\tCity "<<i+1<<" : ";
    cin>>header[i]->city;
    header[i]->time=0;
    header[i]->next=NULL;
  }
  for(int i=0;i<city_num;i++)
  {
    curr=header[i];
    for(int j=0;j<city_num;j++)
    {
      if(i==j)
        continue;
      cout<<"\n\n\tIs there a flight from "<<header[i]->city<<" to "<<header[j]->city<<" ? (y/n) : ";
      cin>>ans;
      if(ans=='y'||ans=='Y')
      {
        temp=new node;
        temp->city=header[j]->city;
        cout<<"\tEnter time of flight (in hours) taken between "<<header[i]->city<<" and "<<header[j]->city<<" : ";
        cin>>temp->time;
        temp->next=NULL;
        curr->next=temp;
        curr=curr->next;
      }
    }
  }

}

void flight::display_list()
{
  node *curr;
  cout<<"\n\n\tThe flights between various cities are as follows : ";
  cout<<"\n\n\t"<<setw(13)<<"DEPARTS FROM"<<setw(3)<<"|"<<setw(13)<<"ARRIVAL AT"<<setw(3)<<"|"<<setw(5)<<"TIME";
  for(int i=0;i<city_num;i++)
  {
    cout<<"\n"; 
    curr=header[i]->next;
    if(curr==NULL)
    {
      cout<<"\n\tThere are no flights from "<<header[i]->city;
      continue;

    }
    while(curr!=NULL)
    {
      cout<<"\n\t"<<setw(13)<<header[i]->city<<setw(3)<<"|"<<setw(13)<<curr->city<<setw(3)<<"|"<<setw(5)<<curr->time;
      curr=curr->next;
    }
  }
}


void flight::init_adj()
{
  for(int i=0;i<city_num;i++)
  {
    for(int j=0;j<city_num;j++)
    {
      adj[i][j]=0;
    }
  }
}

void flight::create_matrix()
{
  char ans;
  float time;
  cout<<"\n\n\tEnter the number of cities : ";
  cin>>city_num;
  cout<<"\n\tEnter the names of the cites : \n";
  for(int i=0;i<city_num;i++)
  {
    cout<<"\t\tCity "<<i+1<<" : ";
    cin>>city[i];   
  }
  init_adj();
  for(int i=0;i<city_num;i++)
  {
    for(int j=i+1;j<city_num;j++)
    {
      cout<<"\n\tIs there a flight between "<<city[i]<<" and "<<city[j]<<" ? (y/n) : ";
      cin>>ans;
      if(ans=='Y'||ans=='y')
      {
        cout<<"\tEnter the time of flight between "<<city[i]<<" and "<<city[j]<<" : ";
        cin>>time;
        adj[i][j]=adj[j][i]=time;
      }
    }
  }
}

void flight::display_matrix()
{
        cout<<"\n\n\tThe flights between various cities are as follows : \n";
        cout<<setw(10)<<" ";
        for(int i=0;i<city_num;i++)
  {
          cout<<setw(3)<<"|"<<setw(10)<<city[i];
  }
  for(int i=0;i<city_num;i++)
  {
          cout<<"\n"<<setw(10)<<city[i];
    for(int j=0;j<city_num;j++)
    {
            if(adj[i][j]==0)
                    cout<<setw(3)<<"|"<<setw(10)<<"-";
            else
              cout<<setw(3)<<"|"<<setw(10)<<adj[i][j];
    }
  }
}

int main()
{
  flight f;
  int x,y;
  char ans;
  do
  {
          cout<<"\n\n\t\t(1) Graph using adjacency list";
          cout<<"\n\t\t(2) Graph using adjacency matrix";
          cout<<"\n\n\tEnter any of the above options : ";
          cin>>x;
          switch(x)
          {
                  case 1:
                         f.create_list();
                         f.display_list();
                         break;
                        case 2:
                               f.create_matrix();
                               f.display_matrix();
                               break;
          }
          cout<<"\n\n\tDo you wish to continue? (y/n) : ";
          cin>>ans; 
  }
  while(ans=='y'||ans=='Y');
  return 0;
}

</xmp>
</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id03').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- 4th Code -->
<div id="id04" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id04').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
        
      Department maintains a student information. The file contains roll number, name, division and address.
      Allow user to add, delete information of student. Display information of particular employee.  
      If record of student does not exist an appropriate message is displayed. 
      If it is, then the system displays the student details. Use sequential file to main the data. 

<xmp>
#include<iostream>
#include<string.h>
#include<fstream>
#include<iomanip>
using namespace std;

class student
{
   string name;
   long roll;
   string div;
   string address;

   public :
     void getdata();
     void display();
     long rroll()
      {
       return roll;
      }
     string rname()
      {
       return name;
      }
     string rdiv()
     {
       return div;
     }
     string radd()
     {
       return address;
     }
};

void student :: getdata()
{
  cout<<"\n\t"<<setw(25)<<"Enter the name : ";
  cin>>name;
  cout<<"\t"<<setw(25)<<"Enter the roll number : ";
  cin>>roll;
  cout<<"\t"<<setw(25)<<"Enter the division : ";
  cin>>div;
  cout<<"\t"<<setw(25)<<"Enter the address : ";
  cin>>address;
}

void student :: display()
{
  cout<<setw(15)<<" Roll number : "<<setw(15)<<roll<<endl;
  cout<<setw(15)<<" Name   : "<<setw(15)<<name<<endl;
  cout<<setw(15)<<" Class   : "<<setw(15)<<div<<endl;
  cout<<setw(15)<<" Address   : "<<setw(15)<<address<<endl;

}

class database
{
  student s;
public:
  void write_to_file();
  void search_roll();
  void search_name();
  void display_record();
  void deletestud();
  void modify();
};

void database::write_to_file()
{
  char ch='n';
  ofstream fout;
  fout.open("stud.txt",ios::out);
  do
  {
      s.getdata();
      fout.write((char *)&s,sizeof(student));
      cout<<"\n\tDo you wish to enter more student details? (y/n) : ";
      cin>>ch;
  }
  while(ch=='y');
  fout.close();
}

void database::search_roll()
{
  int flag=0;
  long no;
  cout<<"\n\tEnter roll number  of the student to search : ";
  cin>>no;
  ifstream fin;
  fin.open("stud.txt");
  while(fin.read((char *)&s,sizeof(student)))
    {
      if(no==s.rroll())
        {
          cout<<"\n\tDetails : \n";
          s.display();
          flag=1;
          break;
        }
    }
   if(flag==0)
      cout<<"\n\tNumber does not exist.";
 fin.close();
}

void database::search_name()
{
  int flag=0;
  string tname;
  cout<<"\n\tEnter the name of the student you wish to search : ";
  cin>>tname;
  ifstream fin;
  fin.open("stud.txt");
  while(fin.read((char *)&s,sizeof(student)))
    {
      if(tname==s.rname())
        {
          cout<<"\n\tDetails : \n";
          s.display();
          flag=1;
          break;
        }
    }
   if(flag==0)
      cout<<"\n\tRecord does not exist.";
 fin.close();
}

void database::display_record()
{
  int count=1;
  ifstream fin;
  fin.open("stud.txt");
  if(!fin)
     cout<<"\n\tError opening the file.";
  else
  {
   cout<<"\n\t\tSTUDENT RECORD : \n";
   while(fin.read((char *)&s,sizeof(student)))
    {
        cout<<"\n\t Record "<<count<<" : \n\n";
        s.display();
        count++;
    }
  }
  fin.close();
}

void database::modify()
{
  fstream file;
  string name1;
    cout<<"\n\tEnter the name whose contents are to be updated : ";
    cin>>name1;
  long int pos;
  int flag = 0;
  file.open("stud.txt", ios::in|ios::out);
  file.seekg(0, ios::beg);
  while (!file.eof())
  {
    pos=file.tellg();                //Returns the position of the current character in the input stream.
    file.read((char*) &s, sizeof(student));
    if(name1==s.rname())
    {
      flag = 1;
      break;
    }
  }
  if (flag == 1)
  {
    s.getdata();
    file.seekg(pos);
    file.write((char*)&s,sizeof(student));
  }
  else
  {
    cout << "\n\tError : Name not found";
  }

}

void database::deletestud()
{
  long int num;
  ifstream file;
  cout<<"\n\tEnter the roll number of student you want to delete : ";
  cin>>num;
  file.open("stud.txt");
  fstream file1;
  file1.open("Temp.txt",ios::app);
  file.seekg(0,ios::beg);
  while(file.read((char*)&s,sizeof(student)))
  {
    if(s.rroll()!=num)
    {
      file1.write((char*)&s,sizeof(student));
    }
  }
  file1.close();
  file.close();
  remove("stud.txt");
  rename("Temp.txt","stud.txt");
  cout<<"\n\tRecord Deleted ..";
}



int main()
{
  char c;
  int ch;
  database d;
  ofstream fout;
  do
  {
    cout<<"\n\n\t\t(1) Add a new student data.";
    cout<<"\n\t\t(2) Display entire student record.";
    cout<<"\n\t\t(3) Search by name.";
    cout<<"\n\t\t(4) Search by roll number.";
    cout<<"\n\t\t(5) Append.";
    cout<<"\n\t\t(6) Delete";
    cout<<"\n\n\tEnter your choice : ";
    cin>>ch;
    switch(ch)
    {
          case 1 : d.write_to_file();
               break;
          case 2 : d.display_record();
               break;
          case 3 : d.search_name();
               break;
          case 4 : d.search_roll();
               break;
          case 5 : d.modify();
               break;
          case 6:  d.deletestud();
            break;
          default : cout<<"\n\tWrong choice ! ";
    }
    cout<<"\n\n\tDo you want to continue? (y/n) : ";
    cin>>c;
      }
      while(c=='y'||c=='Y');
  return 0;
}


</xmp>


</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id04').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>


<!-- CODE 5 -->


<div id="id05" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id05').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
      
       Consider telephone book database of N clients. 
       Make use of a hash table implementation to quickly look up clientâ€˜s telephone number. 
       <xmp>
#include<iostream>
#include<iomanip>
#define max 20
using namespace std;

class client
{
public:
  long int mobNum;
  string address;
  string name;
  client()
  {
    mobNum=0;
    address="Empty";
    name="-";
  }
};

class directory
{
  client c[max];
  int count;
public:
  directory()
  {
    count=0;
  }
  void create();
  void display();
  void search();
  bool overflow();
};

bool directory::overflow()
{
  if(count==max)
    return true;
  else
    return false;
}

void directory::create()
{
  long int mob;
  int loc;
  char ans;
  string nam,add;
  if(!overflow())
  {
    do
    {
      cout<<"\n\tEnter the following data : \n";
      cout<<setw(20)<<"Mobile number : ";
      cin>>mob;
      cout<<setw(20)<<"Name : ";
      cin>>nam;
      cout<<setw(20)<<"Address : ";
      cin>>add;
      loc=mob%max;
      while(1)
      {
        if(c[loc].mobNum==0)
        {
          c[loc].mobNum=mob;
          c[loc].name=nam;
          c[loc].address=add;
          count++;
          break;
        }
        else
          loc=(loc+1)%max;
      }
      cout<<"\n\tDo you wish to add another client's data : ";
      cin>>ans;
    }while(ans=='y'||ans=='Y');
  }
  else
    cout<<"\n\tERROR : Overflow";
}

void directory::search()
{
  long int mob;
  int loc,cnt=0;
  cout<<"\n\tEnter the mobile number you wish to search : ";
  cin>>mob;
  loc=mob%max;
  while(c[loc].mobNum!=mob)
  {
    if(cnt==max)
    {
      cout<<"\n\tMobile number not found";
      return;
    }
    loc=(loc+1)%max;
    cnt++;
  }
    cout<<"\n"<<setw(20)<<"Mobile number : "<<setw(20)<<c[loc].mobNum;
    cout<<"\n"<<setw(20)<<"Name : "<<setw(20)<<c[loc].name;
    cout<<"\n"<<setw(20)<<"Address : "<<setw(20)<<c[loc].address;

}


void directory::display()
{
  for(int i=0;i<max;i++)
  {
    cout<<"\n\n\tClient "<<i+1<<" : ";
    cout<<"\n"<<setw(20)<<"Mobile number : "<<setw(20)<<c[i].mobNum;
    cout<<"\n"<<setw(20)<<"Name : "<<setw(20)<<c[i].name;
    cout<<"\n"<<setw(20)<<"Address : "<<setw(20)<<c[i].address;
  }
}


int main()
{
  directory d;
  char ans;
  int x;
  do
  {
    cout<<"\n\n\t\t(1) Create telephone book database ";
    cout<<"\n\t\t(2) Search a telephone number";
    cout<<"\n\t\t(3) Display";
    cout<<"\n\n\tEnter any of the above options : ";
    cin>>x;
    switch(x)
    {
    case 1:
      d.create();
      break;
    case 2:
      d.search();
      break;
    case 3:
      d.display();
      break;
    }
    cout<<"\n\n\tDo you want to continue : ";
    cin>>ans;
  }while(ans=='y'||ans=='Y');
}

</xmp>
</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id05').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- 6th code -->

<div id="id06" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id06').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
      Convert given binary tree into threaded binary tree. Analyze time and space
      complexity of the algorithm.

<xmp>
#include<iostream>
using namespace std;

class node
{
public:
  int data;
  int lth,rth;
  node *left;
  node *right;
};

class tbt
{
  node *root=NULL;
  node *dummy;
public:
  void create();
  void insert(node *curr,node *temp);
  void display();
};

void tbt::create()
{
  node *ptr;
  ptr=new node;
  cout<<"\n\n\tEnter the data : ";
  cin>>ptr->data;
  ptr->lth=ptr->rth=0;
  if(root==NULL)
  {
    root=ptr;
    dummy=new node;
    dummy->data=-999;
    dummy->left=root;
    dummy->right=dummy;
    dummy->lth=1;
    dummy->rth=0;
    root->left=root->right=dummy;
  }
  else
  {
    insert(root,ptr);
  }
}

void tbt::insert(node *curr,node *temp)
{
  if(temp->data<curr->data)
  {
    if(curr->lth==0)
    {
      temp->left=curr->left;
      temp->lth=0;
      curr->left=temp;
      curr->lth=1;
      temp->right=curr;
      temp->rth=0;
    }
    else
    {
      curr=curr->left;
      insert(curr,temp);
    }
  }
  if(temp->data>curr->data)
  {
    if(curr->rth==0)
    {
      temp->right=curr->right;
      temp->rth=0;
      curr->right=temp;
      curr->rth=1;
      temp->left=curr;
      temp->lth=0;
    }
    else
    {
      curr=curr->right;
      insert(curr,temp);
    }
  }
}

void tbt::display()
{
  node *temp;
  if(root==NULL)
  {
    cout<<"\n\n\tThe tree is empty";
    return;
  }
  temp=root;
  while(temp!=dummy)
  {
    while(temp->lth==1)
    {
      temp=temp->left;
    }
    cout<<"\t"<<temp->data;
    while(temp->rth==0)
    {
      temp=temp->right;
      if(temp==dummy)
      {
        return;
      }
      cout<<"\t"<<temp->data;
    }
    temp=temp->right;
  }
}


int main()
{
  tbt t1;
  int x;
  char choice,y;
  do
  {
    cout<<"\n\n\n\t\t(1) Create threaded binary tree";
    cout<<"\n\t\t(2) Display threaded binary tree";
    cout<<"\n\n\tEnter any of the above choices : ";
    cin>>x;
    switch(x)
    {
      case 1:
        do
        {
          t1.create();
          cout<<"\n\n\tDo you want to add another node? (y/n) : ";
          cin>>y;
        }
        while(y=='y'||y=='Y');
        break;
      case 2:
        cout<<"\n\n\tThe inorder display of threaded binary tree is : \n";
        t1.display();
        break;
      default:
        cout<<"\n\n\tERROR : Wrong choice";
    }
    cout<<"\n\n\tDo you wish to continue? (y/n) : ";
    cin>>choice;
  }
  while(choice=='y'||choice=='Y');
  return 0;
}
</xmp>


</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id06').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- 7th CODE -->



<div id="id07" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id07').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
      A Dictionary stores keywords & its meanings. Provide facility for adding new keywords, deleting keywords, updating values of any entry. Provide facility to display whole data sorted in ascending/ Descending order. Also find how many maximum comparisons may require for finding any keyword.  Use Binary Search Tree for implementation. 

<xmp>
#include<iostream>
#include<iomanip>
using namespace std;

class Word
{
public:
  string word;
  string meaning;
  Word *next;
};

class dictionary
{
  Word *table[26];
public:
  dictionary()
{
    for(int i=0;i<26;i++)
      table[i]=NULL;
}
  void create();
  void insert(Word *a);
  void deleteWord();
  void search();
  void display();
};

void dictionary::create()
{
  char ans;
  Word *temp;
  do
  { 
    temp=new Word;
    cout<<"\n\tEnter the following details : ";
    cout<<"\n"<<setw(12)<<"Word : ";
    cin>>temp->word;
    cout<<setw(12)<<"Meaning : ";
    cin>>temp->meaning;
    temp->next=NULL;
    insert(temp);
    cout<<"\n\tDo you wish to add another word? (y/n) : ";
    cin>>ans;
  }while(ans=='y'||ans=='Y');
}

void dictionary::insert(Word *a)
{
  int loc;
  Word *temp;
  if(a->word[0]<='Z'&&a->word[0]>='A')
    loc=(a->word[0]-'A')%26;
  else if(a->word[0]<='z'&&a->word[0]>='a')
    loc=(a->word[0]-'a')%26;
  else
  {
    cout<<"\n\tERROR : Improper entry";
    return;
  }

  if(table[loc]==NULL)         //table is empty
    table[loc]=a;
  else
  {
    for(temp=table[loc];temp->next!=NULL;temp=temp->next);
    temp->next=a;
  }

}

void dictionary::search()
{
  string wrd;
  cout<<"\n\tEnter the word you wish to search : ";
  cin>>wrd;
  int loc;
  if(wrd[0]<='Z'&&wrd[0]>='A')
    loc=(wrd[0]-'A')%26;
  else if(wrd[0]<='z'&&wrd[0]>='a')
    loc=(wrd[0]-'a')%26;
    Word *temp;
    temp=table[loc];
    while(temp!=NULL)
    {
      if(temp->word==wrd)
      {
        cout<<"\n"<<setw(12)<<"Word : "<<setw(15)<<temp->word;
        cout<<"\n"<<setw(12)<<"Meaning : "<<setw(15)<<temp->meaning;
        return;
      }
      temp=temp->next;
    }
  cout<<"\n\tWord not found";
}

void dictionary::deleteWord()
{
  string wrd;
    cout<<"\n\tEnter the word you wish to delete : ";
    cin>>wrd;
    int loc;
    if(wrd[0]<='Z'&&wrd[0]>='A')
      loc=(wrd[0]-'A')%26;
    else if(wrd[0]<='z'&&wrd[0]>='a')
      loc=(wrd[0]-'a')%26;

      Word *curr,*prev;
      curr=table[loc];
      while(curr!=NULL)
      {
        if(curr->word==wrd)
        {
          break;
        }
        prev=curr;
        curr=curr->next;
      }
      if(curr==NULL)
        cout<<"\n\tERROR : Word not found";
      else
      {
        if(curr==table[loc])
        {
          table[loc]=curr->next;
        }
      //  else
      //  {
      //    prev->next=curr->next;
      //  }
        delete curr;
      }
}

void dictionary::display()
{
  Word *temp;
  char val='A';
  for(int i=0;i<26;i++)
  {
    cout<<"\n\n\t"<<char(val+i)<<" : ";
    if(table[i]!=NULL)
    {
      cout<<"\n\n"<<setw(12)<<"Word : "<<setw(15)<<table[i]->word;
      cout<<"\n"<<setw(12)<<"Meaning : "<<setw(15)<<table[i]->meaning;
      temp=table[i]->next;
      while(temp!=NULL)
      {
        cout<<"\n\n"<<setw(12)<<"Word : "<<setw(15)<<temp->word;
        cout<<"\n"<<setw(12)<<"Meaning : "<<setw(15)<<temp->meaning;
        temp=temp->next;
      }
    }
    else
    {
      cout<<"\n\t\t---";
    }
  }
}

int main()
{
  dictionary d;
  char ans;
  int x;
  do
  {
    cout<<"\n\n\t\t(1) Create the dictionary ";
    cout<<"\n\t\t(2) Search a word";
    cout<<"\n\t\t(3) Display dictionary";
    cout<<"\n\t\t(4) Delete a word";
    cout<<"\n\n\tEnter any of the above options : ";
    cin>>x;
    switch(x)
    {
    case 1:
      d.create();
      break;
    case 2:
      d.search();
      break;
    case 3:
      d.display();
      break;
    case 4:
      d.deleteWord();
      break;
    }
    cout<<"\n\n\tDo you want to continue : ";
    cin>>ans;
  }while(ans=='y'||ans=='Y');
}

</xmp>
</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id07').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- 8th Code-->


<div id="id08" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id08').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>

      Write a program to demonstrate Exception Handling in JAVA.
 

<xmp>
package exceptions;
import java.util.*;

public class Exceptions 
{

    
    public static void main(String[] args) 
    {
        float a, b, c;
   
    Scanner inp = new Scanner(System.in);
    System.out.println("\nEnter two values : ");
   
    // try block
   
    try 
          {
                a = inp.nextFloat();
                b = inp.nextFloat();
                c  = a / b;
                System.out.println("\nResult = " + c);
    }
   
    // catch block
   
    
          catch (ArithmeticException e1) 
          {
      System.out.println("Exception caught: Division by zero : "+e1);
    }
          catch (Exception e) 
          {
      System.out.println("Exception caught : "+e);
    }
    }
    
}

    
    </xmp>
</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id08').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>


<!-- CODE 9 -->
<div id="id09" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id09').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
<xmp>
#include<iostream>
using namespace std;

class node
{
public:
  string keyword;
  string meaning;
  node *left;
  node *right;
};

class avl
{
  node *root=NULL;
public:
  void create();
  node* insert(node *curr,node *temp);
  node* balance(node *temp);
  int diff(node *temp);
  int height(node *temp);
  int max(int a,int b);
  node* LL_rot(node *parent);
  node* RR_rot(node *parent);
  node* LR_rot(node *parent);
  node* RL_rot(node *parent);
  void ascending(node *temp);
  node* deletenode(node *root,string key);
  void deleten();
  node* extractmin(node *t);
        void descending(node *temp);
        void display();
        bool search(node *curr,string key);
        void search_val();
};

void avl::create()
{
  char ans;
  node *temp;
  do
  {
    temp=new node();
    cout<<"\n\n\tEnter the keyword : ";
    cin>>temp->keyword;
    cout<<"\tEnter the meaning : ";
    cin>>temp->meaning;
    temp->left=temp->right=NULL;

      root=insert(root,temp);

    cout<<"\n\n\tDo you wish to add another word? (y/n)";
    cin>>ans;
  }
  while(ans=='y'||ans=='Y');
}


node* avl::insert(node *curr,node* temp)
{
  if(curr==NULL)
  {
    return temp;
  }
  if(temp->keyword<curr->keyword)
  {
    curr->left=insert(curr->left,temp);
    curr=balance(curr);
  }
  else if(temp->keyword>curr->keyword)
  {
    curr->right=insert(curr->right,temp);
    curr=balance(curr);
  }
  return curr;
}

node* avl::balance(node *temp)
{
  int bal;
  bal=diff(temp);
  if(bal>=2)
  {
    if(diff(temp->left)<0)
      temp=LR_rot(temp);
    else
      temp=LL_rot(temp);
  }
  else if(bal<=-2)
  {
    if(diff(temp->right)<0)
      temp=RR_rot(temp);
    else
      temp=RL_rot(temp);
  }
  return temp;
}


int avl::diff(node *temp)
{
  int l,r;
  l=height(temp->left);
  r=height(temp->right);
  return(l-r);
}

int avl::height(node *temp)
{
  if(temp==NULL)
    return(-1);
  else
    return(max(height(temp->left),height(temp->right))+1);
}

int avl::max(int a,int b)
{
  if(a>b)
    return a;
  else
    return b;
}

node* avl::LL_rot(node *parent)
{
  node *temp,*temp1;
  temp=parent->left;
  temp1=temp->right;
  temp->right=parent;
  parent->left=temp1;
  return temp;
}

node* avl::RR_rot(node *parent)
{
  node *temp,*temp1;
  temp=parent->right;
  temp1=temp->left;
  temp->left=parent;
  parent->right=temp1;
  return temp;
}

node* avl::LR_rot(node *parent)
{
  parent->left=RR_rot(parent->left);
  return(LL_rot(parent));
}

node* avl::RL_rot(node *parent)
{
  parent->right=LL_rot(parent->right);
  return(RR_rot(parent));
}

void avl::ascending(node *temp)
{
        if(temp!=NULL)
        {
                ascending(temp->left);
                cout<<"\n\t"<<temp->keyword<<" : "<<temp->meaning;
                ascending(temp->right);
        }
}

void avl::descending(node *temp)
{
        if(temp!=NULL)
        {
                descending(temp->right);
                cout<<"\n\t"<<temp->keyword<<" : "<<temp->meaning;
                descending(temp->left);
        }
}


void avl::display()
{
        cout<<"\n\n\tThe keywords in ascending order are : \n";
        ascending(root);
        cout<<"\n\n\tThe keywords in descending order are : \n";
        descending(root);
}

bool avl::search(node *curr,string key)
{
  if(curr)
  {
    if(curr->keyword==key)
      return true;
    if(curr->keyword>key)
      return search(curr->left,key);
    else
      return search(curr->right,key);
  }
  return false;
}

void avl::search_val()
{
  string key;
        cout<<"\n\tEnter the keyword you wish to search : ";
        cin>>key;
        if(search(root,key))
                cout<<"\t\tThe entered keyword is present in the AVL tree";
        else
                cout<<"\t\tThe entered keyword is not present in the AVL tree";
}


node* avl::deletenode(node* curr,string key)
{
    if ( !curr)
      return curr;
    if ( key < curr->keyword )
        curr->left = deletenode(curr->left, key);

    else if( key > curr->keyword )
        curr->right = deletenode(curr->right, key);

    else
    {
        node *l = curr->left;
        node *r = curr->right;
        delete curr;
        if ( !r )
          return l;
        node *m=r;
        while(m->left)
          m=m->left;
        m->right = extractmin(r);
        m->left = l;
        return balance(m);
    }
    return balance(curr);
}

    node* avl::extractmin(node *t)
    {
        if ( !t->left ) return t->right;
        t->left = extractmin(t->left);
        return balance(t);
    }

void avl::deleten()
{
  string key;
  cout<<"\n\n\tEnter the keyword to be deleted : ";
  cin>>key;
  root=deletenode(root,key);
}

int main()
{
  char c;
  int ch;
  avl a;
  do
  {
    cout<<"\n\n\t\t(1) Insert a keyword in AVL tree.";
    cout<<"\n\t\t(2) Display the AVL tree.";
    cout<<"\n\t\t(3) Search a keyword";
    cout<<"\n\t\t(4) Delete a keyword.";
    cout<<"\n\n\tEnter your choice : ";
    cin>>ch;
    switch(ch)
    {
          case 1 : a.create();
               break;
          case 2 : a.display();
               break;
          case 3 : a.search_val();
               break;
          case 4 : a.deleten();
               break;
          default : cout<<"\n\tWrong choice ! ";
    }
    cout<<"\n\n\tDo you want to continue? (y/n) : ";
    cin>>c;
      }
      while(c=='y'||c=='Y');
  return 0;
}

</xmp>




</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id09').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!--CODE 10 -->

<div id="id10" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id10').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
      Prims Algorithm to find telephone cable network between cities.
<xmp>

#include<iostream>
#include<string.h>
using namespace std;

class graph
{
  int adj[10][10];
  int city_num;
  string city[10];
  int visited[10];
  int mst[10][10];
  public:
  void create();
  void display(int a[10][10]);
  void findmst();
  void init_adj();
  void init_mst();
  void init_visit();
  int city_index(string s);
};

void graph::init_adj()
{
  for(int i=0;i< city_num;i++)
  {
    for(int j=0;j< city_num;j++)
    {
      adj[i][j]=0;
    }
  }
}

void graph::init_mst()
{
  for(int i=0;i< city_num;i++)
  {
    for(int j=0;j< city_num;j++)
    {
      mst[i][j]=0;
    }
  }
}

void graph::init_visit()
{
  for(int i=0;i< city_num;i++)
  {
    visited[i]=0;
  }
}

int graph::city_index(string s)
{
  for(int i=0;i< city_num;i++)
  {
    if(city[i]==s)
    {
      return(i);
    }
  }
}

void graph::create()
{
  char ans;
  int cost;
  cout<<"\n\n\tEnter the number of cities : ";
  cin>>city_num;
  cout<<"\n\tEnter the names of the cites : \n";
  for(int i=0;i< city_num;i++)
  {
    cout<<"\t\tCity "<< i+1<<" : ";
    cin>>city[i];
  }
  init_adj();
  for(int i=0;i< city_num;i++)
  {
    for(int j=i+1;j< city_num;j++)
    {
      cout<<"\n\tIs there a phone line between "<<city[i]<<" and "<<city[j]<<" ? (y/n) : ";
      cin>>ans;
      if(ans=='Y'||ans=='y')
      {
        cout<<"\tEnter the cost of phone line between "<<city[i]<<" and "<<city[j]<<" : ";
        cin>>cost;
        adj[i][j]=adj[j][i]=cost;
      }
    }
  }
  cout<<"\n\n\tThe adjacency matrix is : \n";
  display(adj);
}
        
void graph::findmst()
{
  string source_city;       
  int min,k,cost,loc,s,d;
  init_mst();
  init_visit();
  cout<<"\n\tEnter the source city : ";
  cin>>source_city;
  loc=city_index(source_city);
  visited[loc]=1;
  cost=k=0;
  while(k<city_num)
  {
    min=9999;
    for(int i=0;i<city_num;i++)
    {
      if(visited[i]==1)     
      {
        for(int j=0;j<city_num;j++)
        {
          if(visited[j]==0)
          {
            if(adj[i][j]!=0)
            {
              if(min>adj[i][j])
              {
                min=adj[i][j];
                s=i;
                d=j;
              }
            }
          }
        }
      }
    }
    if(min!=9999)
    {
      mst[s][d]=mst[d][s]=min;
      cost=cost+min;
      visited[d]=1;
    }
    k++;
  }
  cout<<"\n\tThe minimum spanning tree matrix is : \n\n";
  display(mst);
  cout<<"\n\tThe minimum cost required is : "<<cost<<endl;
}

void graph::display(int a[10][10])
{
  for(int i=0;i<city_num;i++)
  {
    for(int j=0;j<city_num;j++)
    {
      cout<<"\t"<<a[i][j];
    }
    cout<<"\n";
  }
}
        
int main()
{
  graph g;
  g.create();
  g.findmst();
  return 0;
}       
</xmp>


</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id10').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- CODE 11 -->


<div id="id11" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id11').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
     Write a Java program to implement Basic Linked List functionality
<xmp>
import java.util.*;
public class LinkedListDemo {

   public static void main(String args[]) {
      // create a linked list
      LinkedList ll = new LinkedList();
      
      // add elements to the linked list
      ll.add("F");
      System.out.println("Original contents of ll: " + ll);
      ll.add("B");
      System.out.println("Original contents of ll: " + ll);
      ll.add("D");
      System.out.println("Original contents of ll: " + ll);
      ll.add("E");
      System.out.println("Original contents of ll: " + ll);
      ll.add("C");
      System.out.println("Original contents of ll: " + ll);
      ll.addLast("Z");
      System.out.println("Original contents of ll: " + ll);
      ll.addFirst("A");
      System.out.println("Original contents of ll: " + ll);
      ll.add(1, "A2");
      System.out.println("Original contents of ll: " + ll);

      // remove elements from the linked list
      ll.remove("F");
      ll.remove(2);
      System.out.println("Contents of ll after deletion: " + ll);
      
      // remove first and last elements
      ll.removeFirst();
      ll.removeLast();
      System.out.println("ll after deleting first and last: " + ll);

      // get and set a value
      /*Object val = ll.get(2);
      ll.set(2, (String) val + " Changed");
      System.out.println("ll after change: " + ll);*/
   }
}
</xmp>
</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id11').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>




<!-- CODE 12 -->


<div id="id12" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id12').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
    <b>Problem Statement</b>
      Queue collection implements First-In Fist-Out behavior on items stored within it.
<xmp>

import java.util.*;
public class QueueDemo {
  static String newLine = System.getProperty("line.separator");
  public static void main(String[] args) {
  
    System.out.println(newLine + "Queue in Java" + newLine);
    System.out.println("-----------------------" + newLine);
    System.out.println("Adding items to the Queue" + newLine);
    //Creating queue would require you to create instannce of LinkedList and assign 
    //it to Queue
    //Object. You cannot create an instance of Queue as it is abstract
    Queue queue = new LinkedList();
    
    //you add elements to queue using add method
    queue.add("apple");
    queue.add("grapes");

    queue.add("pineapple");
    queue.add("mango");
    queue.add("banana");
    System.out.println("ELEMENTS OF QUEUE: ");
    System.out.println(queue+ newLine);
  
    System.out.println("remove element: " + queue.remove() + newLine);
    
    //.element() returns the current element in the queue, here when "java" is removed

    System.out.println("retrieve element: " + queue.element() + newLine);
  }
}

</xmp>


</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id12').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>



<!-- CODE 13 -->

<div id="id13" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id13').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>

      <b>Problem Statement</b>
    Write a Java program to implement Basic Stack functionality
<xmp>

import java.util.*;
public class StackDemo {

   static void showpush(Stack st, int a) {
      st.push(new Integer(a));
      System.out.println("push(" + a + ")");
      System.out.println("stack: " + st);
   }

   static void showpop(Stack st) {
      System.out.print("pop -> ");
      Integer a = (Integer) st.pop();
      System.out.println(a);
      System.out.println("stack: " + st);
   }

   public static void main(String args[]) {
      Stack st = new Stack();
      System.out.println("stack: " + st);
      showpush(st, 42);
      showpush(st, 66);
      showpush(st, 99);
      showpop(st);
      showpop(st);
      showpop(st);
      try {
         showpop(st);
      }catch (EmptyStackException e) {
         System.out.println("empty stack");
      }
   }
}
</xmp>

</p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id13').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>


<div id="id14" class="modal">
  
  <form class="modal-content animate" action="/action_page.php">
    <div class="imgcontainer">
      <span onclick="document.getElementById('id14').style.display='none'" class="close" title="Close Modal">&times;</span>
      
    </div>

    <div class="container">
      <pre>
    <p>
      <b>Problem Statement</b>
      To create ADT that implement the "set" concept.
      a. Add (newElement) -Place a value into the set
      b. Remove (element) Remove the value
      c. Contains (element) Return true if element is in collection
      d. Size () Return number of values in collection
          Iterator () Return an iterator used to loop over collection
      e. Intersection of two sets
      f. Union of two sets
      g. Difference between two sets h.Subset*/

<xmp>
#include<iostream>
  using namespace std;

  class set
  {
    int arr[50];
    int curr;
    int *itr;
  public:
    set()
  {
      curr=0;
      itr=NULL;
  }
    void add(int);
    void remove(int);
    bool contains(int);
    int size()
    {
      return (curr);
    }
    void display();
    int* begin()
    {
    return (&arr[0]);
    }
    int* end()
    {
      return(&arr[curr-1]);
    }
    void intersection(set,set);
    void unionset(set,set);
    void difference(set,set);
    int subset(set,set);
  };
  void set::add(int a)
  {
    arr[curr]=a;
    curr++;
  }
  void set::remove(int a)
  {
    for(itr=begin();itr!=end();itr++)
    {
      if((*itr)==a)
        break;

    }
    for(;itr!=end();itr++)
    {
      *itr=*(itr+1);

    }
    curr--;
  }
  void set::display()
  {
    for(itr=begin();itr-1!=end();itr++)
    {
      cout<<*itr<<"\n";
    }
  }
  bool set::contains(int a)
  {
    for(itr=begin();itr-1!=end();itr++)
    {
      if(*itr==a)
        return true;
    }
    return false;
  }
  void set::intersection(set a,set b)
  {
    for(a.itr=a.begin();a.itr-1!=a.end();a.itr++)
    {
      for(b.itr=b.begin();b.itr-1!=b.end();b.itr++)
      {
        if(*a.itr==*b.itr)
        {
          add(*a.itr);
        }
      }
    }
  }
  void set::unionset(set a,set b)
  {
    int flag;
    for(a.itr=a.begin();a.itr-1!=a.end();a.itr++)
    {
      add(*a.itr);
    }
    for(b.itr=b.begin();b.itr-1!=b.end();b.itr++)
    {
      flag=0;
      for(itr=begin();itr-1!=end();itr++)
      {
        if(*b.itr==*itr)
          flag=1;

      }
      if(flag==0)
        add(*b.itr);
    }
  }
  void set::difference(set a,set b)
  {
    set c;
    c.intersection(a,b);


    int flag;
    for(a.itr=a.begin();a.itr-1!=a.end();a.itr++)
    {
      flag=0;

      for(c.itr=c.begin();c.itr-1!=c.end();c.itr++)
      {

        if(*a.itr==*c.itr)
          flag=1;

      }
      if(flag==0)
        add(*a.itr);
    }
  }
  int set::subset(set b,set a)
  {
    int i=1;
    for(b.itr=b.begin();b.itr!=b.end();b.itr++)
    {
      for(a.itr=a.begin();a.itr!=a.end();a.itr++)
      {
        if(*b.itr==*a.itr)
          {
            i++;
            break;
          }
      }
    }
    if(i==b.size())
      return 1;
    else
      return 0;
    }


int main()
{
  set a[10];
  set d,g,h;
  int w=0,ele,chk,i=0,o=0,l,q,e;
  while(o!=7)
  {
  cout<<"----------------------------------------"<<"\n";
  cout<<"Available sets to perform operations:";
  for(int r=0;r<=i;r++)
  {
    cout<<r+1<<"\t";
  }
  cout<<endl;
  cout<<"----------------------------------------"<<endl;
  cout<<"Press 1:To add a new set"<<endl;
  cout<<"Press 2:To select a set to perform on"<<endl;
  cout<<"Press 3:To Get intersection of two sets"<<endl;
  cout<<"Press 4:To Get unioin of two sets"<<endl;
  cout<<"Press 5:To Get difference of two sets"<<endl;
  cout<<"Press 6:To check if the set is a subset"<<endl;
  cout<<"Press 7:To exit"<<endl;
  cout<<"----------------------------------------"<<endl;
  cin>>o;
  switch(o)
  {
  case 1:i++;
      break;
  case 2:cout<<"Enter the set number to perform the operations"<<"\n";
      cin>>l;
      w=0;
      while(w!=6)
      {
      cout<<"------------------------------------------------------"<<"\n";
      cout<<"Press 1:To Add a new element into the set"<<"\n";
      cout<<"Press 2:To Remove an element from the set"<<"\n";
      cout<<"Press 3:To Check if the element is in the collection"<<"\n";
      cout<<"Press 4:To Get the number of values in the collection"<<"\n";
      cout<<"Press 5:To display the elments of sets"<<"\n";
      cout<<"Press 6:To exit"<<"\n";
      cout<<"------------------------------------------------------"<<"\n";
      cin>>w;
      switch(w)
      {
      case 1:cout<<"Enter the element to add"<<"\n";
          cin>>ele;
          a[l-1].add(ele);
          break;
      case 2:cout<<"Enter the element to remove"<<"\n";
          cin>>ele;
          a[l-1].remove(ele);
          break;
      case 3:cout<<"Enter the element to check if the element is in the collection"<<"\n";
          cin>>ele;
          chk=a[l-1].contains(ele);
          if(chk==1)
            cout<<"Element Present in the collection"<<"\n";
          else
            cout<<"Element not present in the collection"<<"\n";
          break;
      case 4:cout<<"The number of values in the collection is"<<"\n";
          cout<<a[l-1].size()<<endl;
          break;
      case 5:a[l-1].display();
          break;
      case 6:break;
      default:cout<<"Wrong choice"<<endl;
      }
      }
      break;
  case 3:cout<<"Enter the set numbers to get intersection"<<endl;
      cin>>l>>q;
      d.intersection(a[l-1],a[q-1]);
      cout<<"Intersection is"<<"\n";
      d.display();
      break;
  case 4:cout<<"Enter the set numbers to get union"<<"\n";
        cin>>l>>q;
        g.unionset(a[l-1],a[q-1]);
        cout<<"union is"<<"\n";
        g.display();
        break;
  case 5:cout<<"Enter the set numbers to get difference"<<"\n";
        cin>>l>>q;
        h.difference(a[l-1],a[q-1]);
        cout<<"difference is"<<"\n";
        h.display();
        break;
  case 6:cout<<"Enter the set numbers to check subset(first subset,then set)"<<"\n";
      cin>>l>>q;
      e=d.subset(a[l-1],a[q-1]);
      if(e==1)
        cout<<"p"<<"is the subset of"<<"q<<"\n"endl";
      else
        cout<<"l<<" is not the subset of "<<"q<<"endl;
      break;
  case 7:cout<<"Thank you"<<"endl;
      break;
  default:cout<<"Wrong choice"<<"endl;
}
}
}

</xmp>

    </p>
    </pre>
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById('id14').style.display='none'" class="cancelbtn">Cancel</button>
      
    </div>
  </form>
</div>






<script>
// Get the modal
var modal = document.getElementById('id01');

// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal) {
        modal.style.display = "none";
    }
}
</script>

</body>
</html>
